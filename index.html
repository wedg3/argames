<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IRL Storm Hide & Seek (Seeded • No Server)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #map { height:100%; }

    #panel{
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 1000;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.2);
      padding: 10px 12px;
      border-radius: 12px;
      width: 380px;
      max-width: calc(100vw - 24px);
      box-shadow: 0 10px 30px rgba(0,0,0,.15);
    }
    #panel h2{ margin:0 0 8px; font-size: 14px; }
    .note{ font-size:12px; opacity:.9; margin-bottom:8px; line-height:1.3; }
    .row{ display:flex; gap:8px; align-items:center; margin:6px 0; }
    .row label{ width: 165px; font-size: 12px; color:#333; }
    .row input{ flex:1; padding:6px 8px; border-radius: 10px; border:1px solid rgba(0,0,0,.2); }

    button{
      width:100%;
      margin-top: 8px;
      padding: 10px 12px;
      border:0;
      border-radius: 12px;
      background: #111;
      color: #fff;
      cursor: pointer;
      font-weight: 800;
    }
    button.secondary{
      background: #fff;
      color: #111;
      border: 1px solid rgba(0,0,0,.25);
    }
    button:disabled{ opacity:.45; cursor:not-allowed; }

    #status{
      margin-top: 8px;
      font-size: 12px;
      color: #222;
      line-height: 1.35;
      white-space: pre-wrap;
    }

    #healthBox{
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 1000;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.65);
      border-radius: 12px;
      padding: 10px 12px;
      color: #fff;
      min-width: 170px;
      backdrop-filter: blur(6px);
    }
    #healthTitle{ font-size: 12px; opacity: .9; }
    #healthValue{ font-size: 20px; font-weight: 900; margin-top: 2px; }
    #healthSub{ font-size: 12px; opacity: .9; margin-top: 4px; }

    #eliminated{
      position: fixed;
      inset: 0;
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.72);
      color: #fff;
      text-align: center;
      padding: 18px;
    }
    #eliminated .card{
      max-width: 520px;
      width: calc(100vw - 36px);
      background: rgba(20,20,20,.9);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 18px;
      padding: 18px 16px;
      box-shadow: 0 16px 50px rgba(0,0,0,.4);
    }
    #eliminated h1{ margin:0 0 8px; font-size: 26px; }
    #eliminated p{ margin:0; opacity: .92; line-height: 1.35; }

    .pill{
      display:inline-block;
      font-size:11px;
      padding:2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.15);
      background: rgba(255,255,255,.7);
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <h2>IRL Storm (Seeded • No Server)</h2>
    <div class="note">
      <span class="pill">Host</span> Tap the map to set the starting center, then press Start and share the link.<br/>
      <span class="pill">Guests</span> Just open the shared link. No accounts. No shared GPS. Honesty mode.
    </div>

    <div class="row">
      <label>Start radius (m)</label>
      <input id="startRadius" type="number" value="1200" min="100" step="50" />
    </div>

    <div class="row">
      <label>Delay before storm (s)</label>
      <input id="delaySec" type="number" value="60" min="0" step="5" />
    </div>

    <div class="row">
      <label>Shrink factor</label>
      <input id="shrinkFactor" type="number" value="0.7" min="0.2" max="0.95" step="0.05" />
    </div>

    <div class="row">
      <label>Shrink time (s)</label>
      <input id="shrinkTime" type="number" value="45" min="5" step="5" />
    </div>

    <div class="row">
      <label>Hold time (s)</label>
      <input id="holdTime" type="number" value="20" min="0" step="5" />
    </div>

    <div class="row">
      <label>Phases</label>
      <input id="phases" type="number" value="6" min="1" max="20" step="1" />
    </div>

    <div class="row">
      <label>Damage per second</label>
      <input id="dps" type="number" value="6" min="1" max="50" step="1" />
    </div>

    <button id="startBtn" disabled>Start (Generate Seeded Link)</button>
    <button id="copyBtn" class="secondary" disabled>Copy Share Link</button>
    <button id="clearBtn" class="secondary">Clear Link / Reset</button>

    <div id="status">Tip: If you opened a shared link, the game loads automatically.</div>
  </div>

  <div id="healthBox">
    <div id="healthTitle">Your health</div>
    <div id="healthValue">100</div>
    <div id="healthSub">Waiting…</div>
  </div>

  <div id="eliminated">
    <div class="card">
      <h1>ELIMINATED</h1>
      <p>You’re out (honesty mode). Keep watching the storm if you like, but stop playing.</p>
    </div>
  </div>

  <script>
    // ============================================================
    // Utilities: hash params
    // ============================================================
    function parseHashParams() {
      // expects: #k=v&k2=v2
      const h = (location.hash || "").replace(/^#/, "").trim();
      const out = {};
      if (!h) return out;
      for (const part of h.split("&")) {
        const [k, v] = part.split("=");
        if (!k) continue;
        out[decodeURIComponent(k)] = decodeURIComponent(v || "");
      }
      return out;
    }

    function setHashParams(params) {
      const parts = [];
      for (const [k, v] of Object.entries(params)) {
        parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(String(v)));
      }
      location.hash = parts.join("&");
    }

    // ============================================================
    // Seeded RNG (Mulberry32) - deterministic
    // ============================================================
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let x = Math.imul(t ^ (t >>> 15), 1 | t);
        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function randInt(min, max) { // inclusive min, inclusive max
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // ============================================================
    // Map setup (OSM via Leaflet)
    // ============================================================
    const map = L.map('map', { zoomControl: true });
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    map.setView([59.3293, 18.0686], 13); // default Stockholm

    // local-only self marker (never shared)
    let selfMarker = null;
    function setSelfMarker(latlng){
      if (!selfMarker) {
        selfMarker = L.circleMarker(latlng, { radius: 7, weight: 2 }).addTo(map);
      } else selfMarker.setLatLng(latlng);
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        (pos) => setSelfMarker([pos.coords.latitude, pos.coords.longitude]),
        () => {},
        { enableHighAccuracy: true, maximumAge: 1000, timeout: 8000 }
      );
    }

    // Storm circle
    let stormCircle = null;
    function drawStorm(centerLatLng, radiusMeters) {
      if (!stormCircle) {
        stormCircle = L.circle(centerLatLng, { radius: radiusMeters, weight: 3, fillOpacity: 0.08 }).addTo(map);
      } else {
        stormCircle.setLatLng(centerLatLng);
        stormCircle.setRadius(radiusMeters);
      }
    }

    // Host-chosen start center marker
    let startCenterMarker = null;
    let chosenStartCenter = null;

    function setStartCenter(latlng){
      chosenStartCenter = latlng;
      if (!startCenterMarker) {
        startCenterMarker = L.marker(latlng, { draggable: true }).addTo(map);
        startCenterMarker.on("dragend", () => {
          chosenStartCenter = startCenterMarker.getLatLng();
          updateStartEnabled();
          previewStartCircle();
        });
      } else {
        startCenterMarker.setLatLng(latlng);
      }
      updateStartEnabled();
      previewStartCircle();
    }

    function previewStartCircle(){
      const r = Number(startRadiusEl.value);
      if (chosenStartCenter && r > 0) drawStorm(chosenStartCenter, r);
    }

    // Host tap chooses start center
    map.on("click", (e) => {
      // Only do this if not already in an active loaded game
      if (activeState) return;
      setStartCenter(e.latlng);
    });

    // ============================================================
    // Storm geometry helpers (deterministic with seeded RNG)
    // ============================================================
    function randomPointInDiskMeters(center, maxR, rng) {
      // uniform disk: r = sqrt(u)*R
      const u = rng();
      const v = rng();
      const r = Math.sqrt(u) * maxR;
      const theta = 2 * Math.PI * v;

      const east = r * Math.cos(theta);
      const north = r * Math.sin(theta);

      const lat = center.lat;
      const metersPerDegLat = 111320;
      const metersPerDegLng = 111320 * Math.cos(lat * Math.PI/180);

      return L.latLng(
        lat + (north / metersPerDegLat),
        center.lng + (east / metersPerDegLng)
      );
    }

    function chooseNextCenter(currentCenter, currentR, nextR, rng) {
      const maxShift = Math.max(0, currentR - nextR);
      return randomPointInDiskMeters(currentCenter, maxShift, rng);
    }

    // ============================================================
    // Shared state (in URL) - everyone derives the same phases
    // ============================================================
    // activeState:
    // {
    //   version: 1,
    //   seed: int,
    //   startedAtMs: int,
    //   baseCenter: {lat,lng},
    //   baseRadiusM: number,
    //   delaySec, shrinkFactor, shrinkSec, holdSec, phasesCount, dps,
    //   phases: [{toCenter:{lat,lng}, toRadiusM:number}, ...]
    // }
    let activeState = null;

    function buildSeededPhases(st) {
      const rng = mulberry32(st.seed);

      let curCenter = L.latLng(st.baseCenter.lat, st.baseCenter.lng);
      let curR = st.baseRadiusM;

      const phases = [];
      for (let i = 0; i < st.phasesCount; i++) {
        const nextR = Math.max(30, curR * st.shrinkFactor);
        const nextCenter = chooseNextCenter(curCenter, curR, nextR, rng);

        phases.push({
          toCenter: { lat: nextCenter.lat, lng: nextCenter.lng },
          toRadiusM: nextR
        });

        curCenter = nextCenter;
        curR = nextR;
      }
      return phases;
    }

    function computePhaseAtTime(st, tMs) {
      const start = st.startedAtMs;
      const delayEnd = start + st.delaySec*1000;

      if (tMs < start) return { kind: "prestart" };

      // During delay: no damage, circle fixed at base
      if (tMs < delayEnd) {
        return {
          kind: "delay",
          center: st.baseCenter,
          radiusM: st.baseRadiusM,
          tLeftMs: delayEnd - tMs
        };
      }

      let curCenter = st.baseCenter;
      let curR = st.baseRadiusM;
      let cursor = delayEnd;

      for (let i = 0; i < st.phases.length; i++) {
        const ph = st.phases[i];

        const shrinkEnd = cursor + st.shrinkSec*1000;
        const holdEnd = shrinkEnd + st.holdSec*1000;

        if (tMs < shrinkEnd) {
          const a = (tMs - cursor) / (st.shrinkSec*1000);
          const radiusM = curR + (ph.toRadiusM - curR) * a;

          const center = {
            lat: curCenter.lat + (ph.toCenter.lat - curCenter.lat) * a,
            lng: curCenter.lng + (ph.toCenter.lng - curCenter.lng) * a,
          };

          return { kind: "shrinking", phaseIndex: i+1, phaseCount: st.phases.length, center, radiusM, tLeftMs: shrinkEnd - tMs };
        }

        if (tMs < holdEnd) {
          return { kind: "holding", phaseIndex: i+1, phaseCount: st.phases.length, center: ph.toCenter, radiusM: ph.toRadiusM, tLeftMs: holdEnd - tMs };
        }

        curCenter = ph.toCenter;
        curR = ph.toRadiusM;
        cursor = holdEnd;
      }

      return { kind: "finished", center: curCenter, radiusM: curR };
    }

    // ============================================================
    // Health (local-only)
    // ============================================================
    let health = 100;
    let eliminated = false;
    let lastTickMs = Date.now();

    const healthValueEl = document.getElementById("healthValue");
    const healthSubEl = document.getElementById("healthSub");
    const eliminatedEl = document.getElementById("eliminated");

    function setHealth(val){
      health = Math.max(0, Math.min(100, val));
      healthValueEl.textContent = String(Math.round(health));
      if (health <= 0 && !eliminated) {
        eliminated = true;
        eliminatedEl.style.display = "flex";
        healthSubEl.textContent = "You are OUT.";
      }
    }

    function isOutsideCircle(selfLatLng, center, radiusM) {
      if (!selfLatLng) return false; // unknown position => no damage
      const c = L.latLng(center.lat, center.lng);
      const d = selfLatLng.distanceTo(c);
      return d > radiusM;
    }

    // ============================================================
    // UI wiring
    // ============================================================
    const startRadiusEl = document.getElementById("startRadius");
    const delaySecEl = document.getElementById("delaySec");
    const shrinkFactorEl = document.getElementById("shrinkFactor");
    const shrinkTimeEl = document.getElementById("shrinkTime");
    const holdTimeEl = document.getElementById("holdTime");
    const phasesEl = document.getElementById("phases");
    const dpsEl = document.getElementById("dps");

    const startBtn = document.getElementById("startBtn");
    const copyBtn = document.getElementById("copyBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statusEl = document.getElementById("status");

    function updateStartEnabled(){
      startBtn.disabled = !chosenStartCenter;
    }

    function resetLocal() {
      activeState = null;
      eliminated = false;
      eliminatedEl.style.display = "none";
      setHealth(100);
      healthSubEl.textContent = "Waiting…";
      statusEl.textContent = "Reset. Tap map to pick start center, then Start.";
      copyBtn.disabled = true;

      if (stormCircle) { map.removeLayer(stormCircle); stormCircle = null; }
      if (startCenterMarker) { map.removeLayer(startCenterMarker); startCenterMarker = null; }
      chosenStartCenter = null;

      updateStartEnabled();
    }

    clearBtn.onclick = () => {
      location.hash = "";
      resetLocal();
    };

    function readConfigFromInputs() {
      return {
        baseRadiusM: Number(startRadiusEl.value),
        delaySec: Number(delaySecEl.value),
        shrinkFactor: Number(shrinkFactorEl.value),
        shrinkSec: Number(shrinkTimeEl.value),
        holdSec: Number(holdTimeEl.value),
        phasesCount: Number(phasesEl.value),
        dps: Number(dpsEl.value)
      };
    }

    // Start: generate seeded link + load it as active
    startBtn.onclick = () => {
      if (!chosenStartCenter) return;

      const cfg = readConfigFromInputs();
      const seed = (crypto?.getRandomValues)
        ? (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0)
        : (randInt(1, 2147483647) >>> 0);

      const startedAtMs = Date.now();

      const params = {
        v: 1,
        lat: chosenStartCenter.lat.toFixed(6),
        lng: chosenStartCenter.lng.toFixed(6),
        r: Math.round(cfg.baseRadiusM),
        delay: Math.round(cfg.delaySec),
        factor: cfg.shrinkFactor,
        shrink: Math.round(cfg.shrinkSec),
        hold: Math.round(cfg.holdSec),
        phases: Math.round(cfg.phasesCount),
        dps: Math.round(cfg.dps),
        seed: seed,
        t0: startedAtMs
      };

      setHashParams(params);
      loadFromHash(); // immediately start locally
      statusEl.textContent = "Game started. Share the link!";
    };

    copyBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(location.href);
        statusEl.textContent = "Copied share link to clipboard ✅";
      } catch {
        // fallback
        prompt("Copy this link:", location.href);
      }
    };

    // Live preview updates (only if not active)
    [startRadiusEl].forEach(el => el.addEventListener("input", () => { if (!activeState) previewStartCircle(); }));

    // ============================================================
    // Load game from URL hash (guest flow)
    // ============================================================
    function loadFromHash() {
      const p = parseHashParams();
      if (!p || !p.v) return false;

      const v = Number(p.v);
      if (v !== 1) {
        statusEl.textContent = "Unsupported link version.";
        return false;
      }

      const baseCenter = { lat: Number(p.lat), lng: Number(p.lng) };
      const baseRadiusM = Number(p.r);
      const delaySec = Number(p.delay);
      const shrinkFactor = Number(p.factor);
      const shrinkSec = Number(p.shrink);
      const holdSec = Number(p.hold);
      const phasesCount = Number(p.phases);
      const dps = Number(p.dps);
      const seed = Number(p.seed) >>> 0;
      const startedAtMs = Number(p.t0);

      // Basic validation
      if (!isFinite(baseCenter.lat) || !isFinite(baseCenter.lng) || !isFinite(baseRadiusM) || !isFinite(seed) || !isFinite(startedAtMs)) {
        statusEl.textContent = "Invalid link data.";
        return false;
      }

      activeState = {
        version: 1,
        seed,
        startedAtMs,
        baseCenter,
        baseRadiusM,
        delaySec,
        shrinkFactor,
        shrinkSec,
        holdSec,
        phasesCount,
        dps,
        phases: [] // filled below
      };
      activeState.phases = buildSeededPhases(activeState);

      // UI: lock host controls (soft lock)
      copyBtn.disabled = false;
      startBtn.disabled = true;

      // clear markers used for hosting
      if (startCenterMarker) { map.removeLayer(startCenterMarker); startCenterMarker = null; }
      chosenStartCenter = null;

      // Zoom to play area
      map.setView([baseCenter.lat, baseCenter.lng], 14);
      drawStorm(baseCenter, baseRadiusM);

      // Reset local health
      eliminated = false;
      eliminatedEl.style.display = "none";
      setHealth(100);
      healthSubEl.textContent = "Game running.";

      return true;
    }

    // Auto-load on open
    if (!loadFromHash()) {
      statusEl.textContent = "Tap map to pick start center, then Start.";
      updateStartEnabled();
    } else {
      statusEl.textContent = "Loaded from shared link. Game running.";
    }

    // If hash changes (someone pastes a new link), reload
    window.addEventListener("hashchange", () => {
      if (loadFromHash()) statusEl.textContent = "Loaded new shared link.";
    });

    // ============================================================
    // Main loop: render storm + health drain
    // ============================================================
    function loop() {
      const t = Date.now();
      const dt = Math.max(0, (t - lastTickMs) / 1000);
      lastTickMs = t;

      if (activeState) {
        const ph = computePhaseAtTime(activeState, t);
        if (ph?.center && typeof ph.radiusM === "number") {
          drawStorm(ph.center, ph.radiusM);
        }

        // Health drain (no damage during delay)
        if (!eliminated) {
          const myPos = selfMarker ? selfMarker.getLatLng() : null;
          const center = ph?.center ?? activeState.baseCenter;
          const radiusM = ph?.radiusM ?? activeState.baseRadiusM;

          if (ph?.kind === "delay") {
            healthSubEl.textContent = `Storm starts in ${Math.ceil(ph.tLeftMs/1000)}s (no damage).`;
          } else {
            const outside = isOutsideCircle(myPos, center, radiusM);
            if (outside) {
              setHealth(health - activeState.dps * dt);
              healthSubEl.textContent = "OUTSIDE safe zone! Taking damage…";
            } else {
              healthSubEl.textContent = "Inside safe zone.";
            }
          }
        }

        // Status panel info
        if (ph) {
          const secLeft = ph.tLeftMs ? Math.ceil(ph.tLeftMs/1000) : 0;
          let s = `Seed: ${activeState.seed}\n`;
          if (ph.kind === "delay") s += `Storm starts in: ${secLeft}s`;
          if (ph.kind === "shrinking") s += `Phase ${ph.phaseIndex}/${ph.phaseCount}: shrinking (${secLeft}s)`;
          if (ph.kind === "holding") s += `Phase ${ph.phaseIndex}/${ph.phaseCount}: holding (${secLeft}s)`;
          if (ph.kind === "finished") s += `Final circle.`;
          statusEl.textContent = s;
        }
      }

      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
